1.Search in a binary Tree
class Solution {

    void sub(TreeNode* &root, int &val, TreeNode* &temp){
        if(root == NULL){
            return;
        }
        if((root->val)>val){
            sub(root->left, val, temp);
        }
        else if((root->val) == val){
            temp = root;
        }
        else{
            sub(root->right, val, temp);
        }
    }

public:
    TreeNode* searchBST(TreeNode* root, int val) {
        TreeNode* temp = NULL;
        sub(root, val, temp);
        if(temp ==NULL){
            return NULL;
        }
        return temp;
    }
};
2.Minimum in a binary search tree
class Solution {
    
    void sub(Node* &root, int &mini){
        if(root == NULL){
            return;
        }
        mini=min(mini, root->data);
        sub(root->left, mini);
        sub(root->right, mini);
    }
    
  public:
    int minValue(Node* root) {
        int mini=INT_MAX;
        sub(root, mini);
        return mini;
    }
};
3.Find Ceil in a bst tree
int findCeil(Node* root, int k) {
    
    int c = -1;
    
    while(root!=NULL){
        
        if(root->data == k){
            c= root->data;
            return c;
        }
        
        if((root->data)>=k){
            c=root->data;
            root= root->left;
        }
        else{
            root=root->right;            
        }
        
    }
    return c;
   
}
4.Find Floor in Bst
class Solution{

public:
    int floor(Node* root, int x) {
        int f = -1;
        
        while(root!=NULL){
            
            if(root->data == x){
                f=root->data;
                return f;
            }
            if(root->data<=x){
                f=root->data;
                root=root->right;
            }
            else{
                root=root->left;
            }
        }
        return f;
    }
};
5.Insert a node in the bst tree
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL) {
            return new TreeNode(val);
        }
        TreeNode* curr= root;
        while(true){
            if(curr->val <=val){
                if(curr->right!=NULL){
                    curr=curr->right;
                }else{
                    curr->right= new TreeNode(val);
                    break;
                }
            }else{
                if(curr->left!=NULL){
                    curr=curr->left;
                }else{
                    curr->left = new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
};
6.Kth smallest element in a bst
class Solution {

void sub(TreeNode* root, int k, int &ans, int &count){
    if(root == NULL){
        return;
    }

    sub(root->left, k, ans, count);
    count++;
    if(count == k){
        ans = root->val;
        return;
    }
    sub(root->right, k, ans, count);
}

public:
    int kthSmallest(TreeNode* root, int k) {
        int ans;
        int count=0 ;
        sub(root, k, ans, count);
        return ans;
    }
};
7.Check if it is a valid bst or not
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        long long int min = -1000000000000, max = 1000000000000;
        return sub(root, min, max);
    }

    bool sub(TreeNode* root, long long int min, long long int max){
        if(root == NULL){
            return true;
        }
        if(root->val<=min || root->val>=max) return false;
        return sub(root->left, min, root->val) && sub(root->right, root->val, max);
    }
};
8.Lca in a bst 
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return NULL;
        int curr = root->val;
        if(curr>p->val && curr>q->val){
            return lowestCommonAncestor(root->left, p, q);
        }
        if(curr<p->val && curr<q->val){
            return lowestCommonAncestor(root->right, p, q);
        }
        return root;
    }
};
9.
